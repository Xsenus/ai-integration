# Пошаговый сценарий обработки `/v1/analyze-json`

Ниже описан полный цикл, который выполняет сервис при вызове GET или POST
маршрута `/v1/analyze-json`. Формат основан на актуальной реализации
`app/api/analyze_json.py`.

## 1. Приём запроса и первичная валидация
1. FastAPI-роуты `/v1/analyze-json` (POST) и `/v1/analyze-json/{inn}` (GET)
   приводят входные параметры к модели `AnalyzeFromInnRequest` и вызывают
   `_run_analyze` с указанием источника запроса (`"POST"` или `"GET"`).
2. `_run_analyze` нормализует ИНН, логирует исходные параметры и убеждается,
   что доступны обязательные зависимости: строка подключения к Postgres и базовый
   URL внешнего сервиса (`ANALYZE_BASE`). При отсутствии параметров возвращается
   `503` или `400` с детальным описанием проблемы.
3. Если передан флаг `refresh_site`, сервис запускает вспомогательный парсер
   `/v1/parse-site`, чтобы получить свежий текст для анализа.

## 2. Сбор текстовых снапшотов
1. `_collect_latest_pars_site` ищет в `clients_requests` домены для указанного
   ИНН, затем для каждого домена подтягивает последнюю запись из `pars_site`
   (учитывая `company_id` и дату `created_at`).
2. Текст каждого снапшота очищается: удаляются управляющие символы, лишние
   пробелы и повторяющиеся переводы строк. Если после нормализации текст пуст,
   запрос прекращается с ошибкой, чтобы не отправлять некорректные данные
   внешнему сервису.
3. Все ключевые характеристики снапшота (ID, длина текста до и после очистки,
   количество чанков) попадают в логи и в итоговый ответ в массив `runs`.

## 3. Загрузка каталогов (опционально)
1. При `include_catalogs=true` сервис читает таблицы `ib_goods_types` и
   `ib_equipment` (имена и колонки берутся из настроек). Каждая строка
   преобразуется в словарь с `id`, `name` и `vec`.
2. Вектор каталога приводится к контрактному виду: числовой массив `values` и
   строковое представление `literal`. Это гарантирует, что downstream-сервис
   сможет использовать либо pgvector-строку, либо готовый массив чисел.
3. Если загрузка каталога завершилась ошибкой, в логах появляется предупреждение,
   но основной процесс продолжается, передавая пустой список.

## 4. Формирование и отправка запроса во внешний сервис
1. Перед началом итераций определяется конечный URL внешнего сервиса: либо
   `ANALYZE_BASE` уже содержит `/v1/analyze/json`, либо к базе добавляется этот
   суффикс.
2. Для каждого снапшота собирается JSON с полями `pars_id`, очищенным `text_par`,
   `company_id` (если он есть), именами моделей и подготовленными каталогами.
   В логах каталоги заменяются сводкой вида `{items: N, truncated: True}`.
3. HTTP-клиент (`httpx.AsyncClient`) используется повторно между снапшотами,
   что сокращает накладные расходы на установку соединения.
4. При возникновении сетевых ошибок или HTTP-ответа ≥ 400 `_log_and_raise`
   возвращает клиенту `502` с диагностическим контекстом (URL, статус, фрагмент
   текста).

## 5. Обработка ответа сервиса анализа
1. Ответ парсится как JSON. Параллельно формируется две версии: полная
   (`external_response_raw`) и «облегчённая» (`external_response`), где длинные
   строки и каталоги заменяются длинами/сводками.
2. Блок `db_payload` извлекается и передаётся в `_apply_db_payload`. Отсутствие
   блока трактуется как ошибка контракта и приводит к `502`.
3. В логах выводится краткий превью текста LLM (`answer_raw`) и ключевые поля
   распарсенного ответа.

## 6. Применение `db_payload` в БД
1. В рамках одной транзакции обновляется `pars_site.description` и `text_vector`
   (вектор приводится к строке pgvector и сохраняется через `CAST`).
2. Таблицы `ai_site_prodclass`, `ai_site_goods_types` и `ai_site_equipment`
   очищаются и заполняются заново. Для товаров и оборудования используются поля
   `name`/`text`, `match_id`, `score`, а вектор привязывается как текстовый
   параметр, чтобы PostgreSQL смог привести его к типу `vector`.
3. Подсчитывается количество сохранённых строк и итоговый `prodclass`. Эти
   значения отражаются в логах и в итоговом ответе (`goods_saved`,
   `equipment_saved`, `prodclass_score`).

## 7. Формирование ответа клиенту
1. Итоговая структура `AnalyzeFromInnResponse` собирает агрегированные метрики:
   суммарные длины текстов, количество обработанных доменов, сохранённых товаров
   и оборудования, размеры каталогов и тайминги.
2. В массиве `runs` перечисляются подробности по каждому домену: источник
   домена, длина текста, отфильтрованный запрос/ответ и `db_payload`, применённый
   к базе.
3. На верхнем уровне возвращаются `external_response` и `external_response_raw`
   первого успешного запуска, чтобы оператору не приходилось искать их в глубине
   массива.
4. При возникновении ошибок используется схема `AnalyzeFromInnError`, в которой
   сохраняются детали входного запроса и диагностические сообщения.

Документ можно использовать как оперативную памятку для команды, отвечающей за
интеграцию с `/v1/analyze-json`, а также при разборе инцидентов с конкретными
ИНН или доменами.
